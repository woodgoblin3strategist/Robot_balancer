# Robot_balancer
The worst reverse pendulum project.

Худший проект обратного маятника, который вы сможете найти.
Данный проект подразумевался, как часть прохождения университетской практики.
Нужно было собрать обратный маятник и запрограммировать его.
Из оборудования использовался станок лазерной резки и 3D принтер.
Из материалов использовался PLA пластик, фанера 5мм, оргстекло 5 мм.
Компоненты: Arduino UNO, Модуль MPU6050 (GY-521) и сервопривод SG90.

	Теперь немного поподробнее почему можно считать это худшим проектом по обратному маятнику (помимо того, что я криворучка-недоучка).
Задача изначально была поставлена некорректно, предполагалось, что нужно сделать проект без дополнительного питания на серву, питание на неё подавалось с Arduino. Спойлер – это невозможно. Серве просто не хватает мощности, она ведёт себя в 2-3 раза более вяло, чем с отдельным питанием. Так же страдают остальные приборы, подключённые к Arduino, они начинают сбоить, в нашем случае скачут данные с MPU6050, не спасает даже комплементарный фильтр.
Второй момент, подразумевалось, что серва SG90 180 градусная и конструкции подстраивались под данную особенность. На такой серве осуществить не получилось, хотя 90% проекта делалось на ней. Потом просто немного подправился код под серву 360 и это заработало, но плохо.
Серва SG90 имеет пластиковые шестерёнки, что сразу делает её ужасным выбором для приведения конструкции к движению. Шестерёнки стачиваются моментально, можно поменять её на аналог с металлическими шестерёнками - MG90S, но опять же давайте ей постоянные передышки, иначе она перегревается и подыхает. В любом случае это слабые сервы, у них не хватает мощности для хорошего поддержания баланса конструкции, в лучшем случае может поддерживать баланс при маленьком отклонении от угла покоя.

	3D модели делалась в Компасе 3D. Их можно найти в папке …
Carriage – каретка с сервой 180°.
Код для неё: 
Carriage_ degree – угол поворота сервы просто подаётся на неё значением от 0 до180. В этом случае серва начинает сильно дрожать при любом малейшем отклонении маятника. Поэтому рекомендую пользоваться следующим вариантом.
Carriage_speed – здесь серва управляется скоростью. Данный вариан уже хорош, супер мега хорош.
Robot360 – робот балансир с сервой 360°. Несмотря на то, что это версия заработала, лучше даже не лезьте сюда, это просто пару деревяшек залитых клеем. Сделайте свою версию и воспользуйтесь данным кодом для своей конструкции. Главное, сделайте возможность быстрой смены серв и минимизируйте любой люфт, прикрепите сверху хороший груз, не сильно лёгкий, но и не шибко тяжёлый.
Код для неё:
robot360 – скорость кручения задаётся, отклонением от 90°. При небольшом отклонении серва не шевелится, так что стоит проверить насколько это большие углы. Можно сделать это с помощью кода от сюда
https://coolcode.ru/arduino-vzaimodeystvie-s-kompyuterom-cherez-usb-port/
 
Немного программных деталей.
Некоторые куски кода основываются на данном проекте (чтение данных с MPU6050). Но в остальном всё пришлось менять из-за конфликта библиотек и странной работы сервы с прерываниями.
https://robototehnika.ru/content/article/balansiruyushchiy-robot-na-arduino/

Для чтения данных из MPU6050 используется библиотека https://github.com/jrowberg/i2cdevlib/tree/master/Arduino/MPU6050.
Устранение ошибок смещения акселерометра и гироскопа
Загрузите в Arduino скетч MPU6050_calibration.ino для калибровки смещений MPU6050. В скетче в функции setup() есть следующие строчки:
  mpu.setYAccelOffset(594);
  mpu.setZAccelOffset(713);
  mpu.setXGyroOffset(-203);
В этих строчках замените числа на полученные при калибровке.
В последствии, если обнаружите, что датчик немного наклонен, можно будет немного подправить это изменив значение targetAngle.
#define targetAngle 0.7  //-2.5

	Чтобы забалансить конструкцию используется PID-регулятор. Если ничего не знаете о нём то можете почитать здесь:
https://alexgyver.ru/lessons/pid/
	В самом коде коэффициенты регулятора меняем в начале  
Или в процессе использования программы можно делать это в Serial Monitor. Например, d20 чтоб задать дифференциальному коэффициенту значение 20. Но советую всё же каждый раз перезапускать программу при изменении коэффициентов. 
Если захочется почитать подробней, то залезайте в файл “отчёт.doc”. Ну и сам код достаточно подробно закомментирован. 
